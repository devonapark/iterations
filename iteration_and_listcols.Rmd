---
title: "Iterations and List Columns"
output: github_document
date: "2025-11-06"
---
#### Always add at the beginning
```{r, include = FALSE, message = FALSE, warning = FALSE}
library(tidyverse)

knitr::opts_chunk$set(
	echo = TRUE,
	warning = FALSE,
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)

theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d
```

#### Load key packages.

```{r}
library(tidyverse)
library(rvest)
```

--------------------
UNIMPORTANT

When “observations” that I want to store become more complex than single values (for example, each row many contain a few scalar observations as well a complete data set)
For this we can use list columns are an appropriate column type. Map functions provide a way to interact with those columns.



GOAL: Use map functions and iterate over listcolumns in data frames.

What are `LISTS`?
- Note: vectors are limited to a single data class (aka they can only be ALL characters, numeric or all logic)

```{r}
#Trying to join the following vectors will result in coersion, as would creating vectors of mixed types. 

vec_numeric = 5:8
vec_char = c("My", "name", "is", "Jeff")
vec_logical = c(TRUE, TRUE, TRUE, FALSE)
```

^If we want to combine these, we would use a list.

Lists contain indexed elements. Indexed elements themselves can be scalars, vectors, or other things entirely.
------------------------------------

## Make a list

```{r}
l = 
  list(
    vec_numeric = 1:23,
    char_vec = c("Jeff"), #already with these first two lines you could not put this in a DF because vec_numeric has length 23 and char_vec has length 1. 
    mat = matrix(1:8, nrow = 2, ncol = 4), 
    summary = summary(rnorm(1000, mean = 4)) #if you give me a sample (normally distributed) of 1000 observations with mean 4, this will output min, max, median and 1st and 3rd quartile
  )

l



#Lists can be accessed using names or indices, and the things in lists can be accessed in the way you would usually access an object of that type.

#all get the vec_numeric portion
l$vec_numeric #dollar sign extracts things from a list (takes it out of a list) (HE GENERALLY AVOIDS) (leave it in a list if youve put it in a list)
l[[1]] ## of variable in list
l[["vec_numeric"]]

#gets the first three observations of variable in list
l[[1]][1:3]

l[[2]]
l$mat
```


## Make a different list
`for` loops

```{r}
list_normals = 
  list(
    a = rnorm(30, mean = 3, sd = 1),
    b = rnorm(30, mean = 30, sd = 1),
    c = rnorm(30, mean = 3, sd = 10),
    d = rnorm(30, mean = -3, sd = 4)
  )

#check that it is a list
is.list(list_normals)
```

### A couple ways to use mean_and_sd function from last time 

Path 1: copy and paste the function from last time

```{r}
mean_and_sd = function(x) {
  
  if (!is.numeric(x)) {
    stop("Argument x should be numeric")
  } 
  
  else if (length(x) < 5) {
    stop("Only compute mean and sd when the input has 5 or more numbers")
  }
  
  mean_x = mean(x, na.rm = TRUE)
  sd_x = sd(x, na.rm = TRUE)

  c(mean_x, sd_x)
}

```


Path 2:get it this way from source folder and script 

```{r}

#CHECK HOW THIS WORKS

source("source/mean_and_sd.R")
```


### Apply the mean_and_sd function to each element of list_norms using the lines below
```{r}
mean_and_sd(list_normals[[1]])
mean_and_sd(list_normals[[2]])
mean_and_sd(list_normals[[3]])
mean_and_sd(list_normals[[4]])
```

However, now we are doing this multiple time, and if we wanted to save these results it would get even more tedious, so.....

### Use a loop to iterate!!

```{r}
output = vector("list", length = 4) 

#output is a vector of type list with length equal to 4 becuase we have 4 inputs (and subsequently 4 outputs) --> this is a way to define an empty list with four blank spots

#now create the for loop -- iterating from 1 to 4
#first time i is going to be 1 then 2 and so on until 4
for (i in 1:4) {
  
  output[[i]] = mean_and_sd(list_normals[[i]])
  
}

#list_normals[[i]] --> i=1 means a and so on

output
```

^In this example, Jeff bypassed a common first step in writing loops because he already had the function he wanted to repeat. Frequently, however, he’ll start with repeated code segements, then abstract the underlying process into a function, and then wrap things up in a for loop.


# Use `map` to do the same thing.

`MAP`
A criticism of for loops is that there’s a lot of overhead – you have to define your output vector / list, there’s the for loop bookkeeping to do, etc – that distracts from the purpose of the code. In this case, we want to apply mean_and_sd to each element of list_norms, but we have to scan inside the for loop to figure that out.

The map functions in purrr try to make the purpose of your code clear. Compare the loop above to the line below.

```{r}
output = map(list_normals, mean_and_sd)

# map says, "tell me the input list and what function you want me to apply to it each time"

output = map(list_normals, median)
```

### Check out some `map` variants

`MAP` focuses on the fucntion we want to apply by removing the bookkeeping

```{r}
#collapses this into a dataframe
map_dfr(list_normals, mean_and_sd)

#input list is named a,b,c,d. If i want to keep that ID varaible, i can include the argument ".id = "sample"" 
map_dfr(list_normals, mean_and_sd, .id = "sample")


#if we know our result is going to be a single number
#simplifies the results in a predictable way (not as a list)
map_dbl(list_normals, median) #we can define our output whichever way we want. 

#^ you dont need to set the length of your output becuase map will utomatically set it 


#The first argument to map is the list (or vector, or data frame) we want to iterate over, and the second argument is the function we want to apply to each element. The line above will produce the same output as the previous loop, but is clearer and easier to understand (once you’re used to map …).

#This code (using map) is why we pointed out in writing functions that functions can be passed as arguments to other functions. The second argument in map(list_norms, mean_and_sd) is a function we just wrote. To see how powerful this can be, suppose we wanted to apply a different function, say median, to each column of list_norms. The chunk below includes both the loop and the map approach.
```





## LIST COLUMNS

I have list_normals (but I prefer dataframes) so, let's try to put my list into a dataframe!!

```{r}
#define dataframe 

listcol_df = 
  tibble(
    name = c("a", "b", "c", "d"),
    sample = list_normals
  )

#the reason this works is because "name" and "sample" BOTH have length 4. As long as they have the same length i can put them next to eachother in the same dataframe and call them whatever i want 

#so we have name (type character) with values a-d and sample (type dbl) with each cell having a list comprised of 30 numbers

```

### Did this really work??

```{r}
pull(listcol_df, name)
pull(listcol_df, sample)
```

### can I apply `mean_and_sd`??

```{r}

pull(listcol_df, sample[[1]]) #gets all the numbers in row 1 or from a
#then pull for mean_and_sd function
mean_and_sd(pull(listcol_df, sample)[[1]])
mean_and_sd(pull(listcol_df, sample)[[2]])
mean_and_sd(pull(listcol_df, sample)[[3]])
mean_and_sd(pull(listcol_df, sample)[[4]])
```

### iterate using `map`

```{r}
map(pull(listcol_df, sample), mean_and_sd)

#previously i had mapped across list_normals using mean_and_sd, but now it is a list in my df

#pull(listcol_df, sample) --> accesses the input list
  #so i call on the dataframe and the specify "saple" becuase this is the     colmn in the df that houses my list 
```


### adding a column ...

Ideally I want the output I just got to be in the dataframe that I just iterated over. So, I want to add a column to it. 

(aka the values i just got (mean and sd), i want to put into listcol_df)

```{r}

#like when we want to add any columns, use MUTATE

listcol_df = 
  listcol_df |> 
  mutate(
    summary = map(sample, mean_and_sd)  #map across the samples and apply this function 
  )



listcol_df |> pull(summary)

pull(listcol_df, summary)


#^both do the same thing
```


```{r}


listcol_df |> 
  select(-sample) |>  # I may not care about the sample anymore, so i can remove this
  unnest(summary) 

#unnest allows me to unnest a particular column (takes the 1x2 tibble from mean_and_sd function output that is now in summary and makes it two columns)

#it takes the name of columns that were originally in the tibble

#technically you can unnest the same column as well 


```

# Let's look at a couple more examples 

## Revisit NSDUH

```{r}

#Import data from online 
nsduh_url = "http://samhda.s3-us-gov-west-1.amazonaws.com/s3fs-public/field-uploads/2k15StateFiles/NSDUHsaeShortTermCHG2015.htm"

#read in HTML
nsduh_html = read_html(nsduh_url)

#Function to extract certain table doing the following (specifics to data cleaning process is in previous class "writing_functions)
nsduh_import = function(html, table_num) {
  
  data = 
    html |> 
    html_table() |> 
    nth(table_num) |>
    slice(-1) |> 
    select(-contains("P Value")) |>
    pivot_longer(
      -State,
      names_to = "age_year", 
      values_to = "percent") |>
    separate(age_year, into = c("age", "year"), sep = "\\(") |>
    mutate(
      year = str_replace(year, "\\)", ""),
      percent = str_replace(percent, "[a-c]$", ""),
      percent = as.numeric(percent)) |>
    filter(!(State %in% c("Total U.S.", "Northeast", "Midwest", "South", "West")))
  
  data
  
}

nsduh_import(nsduh_html, table_num = 1)
nsduh_import(nsduh_html, table_num = 2)
nsduh_import(nsduh_html, table_num = 3)
```



### Try this with a `for` loop

```{r}
#define blank list first with length three
output = vector("list", length = 3) 


for (i in 1:3) {
  
  output[[i]] = nsduh_import(html = nsduh_html, i)
  
}
```


### Do this with `map`

```{r}
map(1:3, nsduh_import, html = nsduh_html)

#input that i care about is just 1:3
#nsduh_import has two arguments (html and i), and in MAP, whatever things are not changing (fixed everywhere) are written after everything else 



#i is 1:3 in this map function
```



### Do this all in a dataframe.

We dont want import and output vectors just floating around, so we are gonna tidy this up by putting it all in a dataframe

```{r}
nsduh_df = 
  tibble(
    name = c("marj year", "marj month", "marj first"),
    number = 1:3
  ) |> 
  
  #creates a quick data frame with just name of table we will eventually     want to pull and then the number of the datatable 
  
  #eventually we want to add column with a list of the imported and tidy     datasets 
  
  mutate(
    table = map(number, nsduh_import, html = nsduh_html) 
    
    #map across table number that i am interested in (number column is         defined in section above) apply nsduh_import function which takes two      arguments html (which is not changing) and table number (which is          defined as number)
    
  ) |> 
  unnest(table)
```


## Look at weather data

```{r}
library(p8105.datasets)
data("weather_df")
```

```{r}
weather_df |> 
  filter(name == "CentralPark_NY") |> 
  ggplot(aes(x = tmin, y = tmax)) + 
  geom_point() + 
  geom_smooth(method = "lm") #regression line that goes through the middle of this 
```

Let's do a regression

```{r}
weather_df |> 
  filter(name == "CentralPark_NY") |> 
  lm(tmax ~ tmin, data = _) #lm means linear model
  #data = _ becuase dataframe does not go first, so we need to use a place holder, "_"

weather_df |> 
  filter(name == "Molokai_HI") |> 
  lm(tmax ~ tmin, data = _)

weather_df |> 
  filter(name == "Waterhole_WA") |> 
  lm(tmax ~ tmin, data = _)

```

### Let's iterate differently...
(imagine if you had 100 weather stations)

```{r}
weather_nest = 
  weather_df |> 
  nest(data = date:tmin)

#nest: into the data column I want to colapse everything from data to tmin 
```

```{r}
lm(tmax ~ tmin, data = pull(weather_nest, data)[[1]])

#run linear model of tmax against tmin, where the dataset is going to be taken out of the data column of weather_nest for only the first row 

#pull out data column from weather_nest and only take the first element (central park)

lm(tmax ~ tmin, data = pull(weather_nest, data)[[2]])
lm(tmax ~ tmin, data = pull(weather_nest, data)[[3]])
```

### Do this using `map` .. 

```{r}
#first step, create a new function
#function of a dataframe that runs a linear model of tmax against tmin using some input dataframe

weather_lm = function(df) {
  
  lm(tmax ~ tmin, data = df)
  
}
```

```{r}
map(pull(weather_nest, data), weather_lm)

#pull(weather_nest, data) is my input list
#weather_lm is the function i want to run on my input list
```



```{r}
weather_nest |> 
  mutate(
    lm_fits = map(data, weather_lm) #map across the data column using my lm function 
  ) 
```
# How can we edit lm_fits so we can put it into our dataframe (unnest it)

In someway this is an extreme version of groupby and summarize



