---
title: "Iterations and List Columns"
output: github_document
date: "2025-11-06"
---
Always add at the beginning
```{r, include = FALSE, message = FALSE, warning = FALSE}
library(tidyverse)

knitr::opts_chunk$set(
	echo = TRUE,
	warning = FALSE,
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)

theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d
```

Load key packages.

```{r}
library(tidyverse)
library(rvest)
```

When “observations” that I want to store become more complex than single values (for example, each row many contain a few scalar observations as well a complete data set)
For this we can use list columns are an appropriate column type. Map functions provide a way to interact with those columns.



GOAL: Use map functions and iterate over listcolumns in data frames.



What are `LISTS`?
- Note: vectors are limited to a single data class (aka they can only be ALL characters, numeric or all logic)

```{r}
#Trying to join the following vectors will result in coersion, as would creating vectors of mixed types. 

vec_numeric = 5:8
vec_char = c("My", "name", "is", "Jeff")
vec_logical = c(TRUE, TRUE, TRUE, FALSE)
```

If we want to combine these, we would use a list:


Lists contain indexed elements. Indexed elements themselves can be scalars, vectors, or other things entirely.


## Make a list

```{r}
l = 
  list(
    vec_numeric = 1:23,
    char_vec = c("Jeff"), 
    mat = matrix(1:8, nrow = 2, ncol = 4), 
    summary = summary(rnorm(1000, mean = 4))
  )

l



#Lists can be accessed using names or indices, and the things in lists can be accessed in the way you would usually access an object of that type.

#all get the vec_numeric portion
l$vec_numeric
l[[1]] ## of variable in list
l[["vec_numeric"]]

#gets the first three observations of variable in list
l[[1]][1:3]

l[[2]]
l$mat
```


## Make a different list
`for` loops

```{r}
list_normals = 
  list(
    a = rnorm(30, mean = 3, sd = 1),
    b = rnorm(30, mean = 30, sd = 1),
    c = rnorm(30, mean = 3, sd = 10),
    d = rnorm(30, mean = -3, sd = 4)
  )

#check that it is a list
is.list(list_normals)
```

(copy and paste the function from last time)

```{r}
mean_and_sd = function(x) {
  
  if (!is.numeric(x)) {
    stop("Argument x should be numeric")
  } 
  
  else if (length(x) < 5) {
    stop("Only compute mean and sd when the input has 5 or more numbers")
  }
  
  mean_x = mean(x, na.rm = TRUE)
  sd_x = sd(x, na.rm = TRUE)

  c(mean_x, sd_x)
}

mean_and_sd(x_vec)
```


or get it this way

```{r}

#CHECK HOW THIS WORKS

source("source/mean_and_sd.R")
```


Apply the mean_and_sd function to each element of list_norms using the lines below
```{r}
mean_and_sd(list_normals[[1]])
mean_and_sd(list_normals[[2]])
mean_and_sd(list_normals[[3]])
mean_and_sd(list_normals[[4]])
```

Use a loop to iterate!!

```{r}
output = vector("list", length = 4)

for (i in 1:4) {
  
  output[[i]] = mean_and_sd(list_normals[[i]])
  
}

output
```

^In this example, Jeff bypassed a common first step in writing loops because he already had the function he wanted to repeat. Frequently, however, he’ll start with repeated code segements, then abstract the underlying process into a function, and then wrap things up in a for loop.


`MAP`
A criticism of for loops is that there’s a lot of overhead – you have to define your output vector / list, there’s the for loop bookkeeping to do, etc – that distracts from the purpose of the code. In this case, we want to apply mean_and_sd to each element of list_norms, but we have to scan inside the for loop to figure that out.

The map functions in purrr try to make the purpose of your code clear. Compare the loop above to the line below.


Use `map` to do the same thing.

```{r}
output = map(list_normals, mean_and_sd)

output = map(list_normals, median)
```

Check out some `map` variants

`MAP` focuses on the fucntion we want to apply by removing the bookkeeping

```{r}
map_dfr(list_normals, mean_and_sd, .id = "sample")

map_dbl(list_normals, median)


#The first argument to map is the list (or vector, or data frame) we want to iterate over, and the second argument is the function we want to apply to each element. The line above will produce the same output as the previous loop, but is clearer and easier to understand (once you’re used to map …).

#This code (using map) is why we pointed out in writing functions that functions can be passed as arguments to other functions. The second argument in map(list_norms, mean_and_sd) is a function we just wrote. To see how powerful this can be, suppose we wanted to apply a different function, say median, to each column of list_norms. The chunk below includes both the loop and the map approach.
```











## LIST COLUMNS

Try to put my list into a dataframe!!

```{r}
listcol_df = 
  tibble(
    name = c("a", "b", "c", "d"),
    sample = list_normals
  )
```

Did this really work??

```{r}
pull(listcol_df, name)
pull(listcol_df, sample)
```

can I apply `mean_and_sd`??

```{r}
mean_and_sd(pull(listcol_df, sample)[[1]])
mean_and_sd(pull(listcol_df, sample)[[2]])
mean_and_sd(pull(listcol_df, sample)[[3]])
mean_and_sd(pull(listcol_df, sample)[[4]])
```

iterate using `map`


```{r}
map(pull(listcol_df, sample), mean_and_sd)
```


adding a column ...

```{r}
listcol_df = 
  listcol_df |> 
  mutate(
    summary = map(sample, mean_and_sd)
  )

pull(listcol_df, summary)
```


```{r}
listcol_df |> 
  select(-sample) |> 
  unnest(summary)
```



## Revisit NSDUH

```{r}
nsduh_url = "http://samhda.s3-us-gov-west-1.amazonaws.com/s3fs-public/field-uploads/2k15StateFiles/NSDUHsaeShortTermCHG2015.htm"

nsduh_html = read_html(nsduh_url)

nsduh_import = function(html, table_num) {
  
  data = 
    html |> 
    html_table() |> 
    nth(table_num) |>
    slice(-1) |> 
    select(-contains("P Value")) |>
    pivot_longer(
      -State,
      names_to = "age_year", 
      values_to = "percent") |>
    separate(age_year, into = c("age", "year"), sep = "\\(") |>
    mutate(
      year = str_replace(year, "\\)", ""),
      percent = str_replace(percent, "[a-c]$", ""),
      percent = as.numeric(percent)) |>
    filter(!(State %in% c("Total U.S.", "Northeast", "Midwest", "South", "West")))
  
  data
  
}

nsduh_import(nsduh_html, table_num = 1)
nsduh_import(nsduh_html, table_num = 2)
nsduh_import(nsduh_html, table_num = 3)
```



Try this with a `for` loop

```{r}
output = vector("list", length = 3)

for (i in 1:3) {
  
  output[[i]] = nsduh_import(html = nsduh_html, i)
  
}
```


Do this with `map`

```{r}
map(1:3, nsduh_import, html = nsduh_html)
```



Do this all in a dataframe.

```{r}
nsduh_df = 
  tibble(
    name = c("marj year", "marj month", "marj first"),
    number = 1:3
  ) |> 
  mutate(
    table = map(number, nsduh_import, html = nsduh_html)
  ) |> 
  unnest(table)
```


## Look at weather data



```{r}
library(p8105.datasets)
data("weather_df")
```

```{r}
weather_df |> 
  filter(name == "CentralPark_NY") |> 
  ggplot(aes(x = tmin, y = tmax)) + 
  geom_point() + 
  geom_smooth(method = "lm")
```

Let's do a regression

```{r}
weather_df |> 
  filter(name == "CentralPark_NY") |> 
  lm(tmax ~ tmin, data = _)

weather_df |> 
  filter(name == "Molokai_HI") |> 
  lm(tmax ~ tmin, data = _)

weather_df |> 
  filter(name == "Waterhole_WA") |> 
  lm(tmax ~ tmin, data = _)

```

Let's iterate differently...

```{r}
weather_nest = 
  weather_df |> 
  nest(data = date:tmin)
```

```{r}
lm(tmax ~ tmin, data = pull(weather_nest, data)[[1]])
lm(tmax ~ tmin, data = pull(weather_nest, data)[[2]])
lm(tmax ~ tmin, data = pull(weather_nest, data)[[3]])
```

Do this using `map` .. 

```{r}
weather_lm = function(df) {
  
  lm(tmax ~ tmin, data = df)
  
}
```

```{r}
map(pull(weather_nest, data), weather_lm)
```



```{r}
weather_nest |> 
  mutate(
    lm_fits = map(data, weather_lm)
  )
```